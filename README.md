**ПРЕДМЕТНО-ОРИЕНТИРОВАННОЕ**
**ПРОЕКТИРОВАНИЕ С**
**LARAVEL**

**МАРТИН ДЖО**

Единственный подход к проектированию, который вам нужен

---

**Основные понятия**

    Domain-Driven Design
    Работа с данными
    Объекты-значения
    Объекты передачи данных
    Репозитории
    Пользовательские построители запросов
    Сервисы
    Действия
    ViewModels
    CQRS
    Состояния и переходы
    Домены и приложения
    Преимущества и недостатки

**Проектирование программного обеспечения для e-mail маркетинга**

    Обзор
        Подписчики
        Рассылки
        Последовательности
        Автоматизации
        Другие функции
        Почему e-mail маркетинг?
    Пользовательские истории
    Моделирование данных
        Подписчики
        Рассылки
        Отправленные письма
        Короткое замечание о производительности
        Последовательности
        Автоматизации
    Домены

**Создание программного обеспечения для e-mail маркетинга**

    Настройка доменов и приложений
    Подписчики
        Создание нового подписчика
        Обновление подписчика

Martin Joo — Предметно-ориентированное проектирование с Laravel

1 / 327


---

        View Models
        Vue Component
        Получение подписчиков
        Реальная мощь DTO и действий
        Заключение

    Рассылки
        DTO рассылки
        Обработка фильтров
        Upserting рассылки
        Фильтрация подписчиков
        Отправка рассылки
        Вычисление эффективности рассылки
        Предпросмотр рассылки
        Получение рассылок

    Последовательности
        Создание последовательности
        Продвижение последовательности
        Рефакторинг
        Обновление статуса подписчика
        Вычисление эффективности последовательности
        Прогресс последовательности

    Панель и отчеты
        Количество новых подписчиков
        Вся эффективность за все время
        Подписчики

    Автоматизации
        Upserting автоматизаций
        Запуск автоматизаций
    Заключение
    Спасибо

Martin Joo — Предметно-ориентированное проектирование с Laravel

2 / 327

---

# Основные понятия
## Предметно-ориентированное проектирование**

Прежде всего, мы должны ответить на самый очевидный вопрос: что такое предметно-ориентированное проектирование (Domain-Driven Design, DDD)?

DDD — это подход к разработке программного обеспечения, который пытается максимально сблизить бизнес-язык и код. Это наиболее важный атрибут этого подхода. Но по какой-то причине DDD — одна из самых неправильно понятых и чрезмерно усложнённых тем в сообществе разработчиков, поэтому я постараюсь объяснить её просто.

DDD учит нас двум основным вещам:

    **Стратегическое проектирование**
    **Техническое проектирование**

По моему честному мнению, стратегическое проектирование гораздо важнее технических аспектов. Трудно подытожить это одной крутой фразой, но ты увидишь, что я имею в виду, в оставшейся части книги. Пока что это основные столпы:

    * Домены и пространства имён. Позже я расскажу, что такое домен, но DDD учит нас структурировать код очень выразительно и логично.
    * Выбор правильных названий. Например, если в бизнесе пользователей называют «клиентами» или «сотрудниками», ты должен переименовать свой класс User, чтобы следовать этой конвенции.
    * Классы и объекты должны выражать заложенное в них намерение. В самом простом Laravel-приложении есть модели и контроллеры. Что ты думаешь, когда видишь проект с 50 моделями и 50 контроллерами? Ты видишь основную предметную область приложения, но тебе придётся копнуть глубже, если хочешь хорошо понимать функционал, верно? А как насчёт 300 моделей и 500 контроллеров? У тебя нет шансов осознать такое приложение.

В большинстве проектов разработчики предпочитают технические термины бизнес-концепциям. Это естественно. В конце концов, мы технические люди. Но у меня вопрос: действительно ли эти технические термины так важны?

Martin Joo — Предметно-ориентированное проектирование с Laravel

3 / 327

---

Позволь показать тебе пример. Это фрагмент из одного из моих приложений, которое я написал 28 октября 2016 года после того, как закончил книгу по шаблонам проектирования. Взгляни на него (это не Laravel):

```php
class Search_View_Container_Factory_Project
{
    /**
     * @var Search_View_Container_Relation_Project
     */
    private static $_relationContainer;

    /**
     * @param array $data
     * @return Search_View_Container_Project
     */
    public static function createContainer(array $data)
    {
        if ($data['current'] == 'complex') {
            return self::createComplex($data);
        } else {
            return self::createSimple($data);
        }
    }

    /**
     * @param array $data
     * @return Search_View_Container_Project
     */
    private static function createSimple(array $data)
    {
        $container = new Search_View_Container_Project('simple');
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

4 / 327

---

```php
    $container->setSearchTerm(
        Arr::get($data, 'search_term')
    );

    $relationContainer = new 
        Search_View_Container_Relation_Project();

    $industryModel = new Model_Industry();
    $industries = $industryModel->getAll();

    foreach ($industries as $industry) {
        $industryItem = new Search_View_Container_Relation_Item(
            $industry, 
            Search_View_Container_Relation_Item::TYPE_INDUSTRY, 
            false
        );

        $relationContainer->addItem(
            $industryItem, 
            Search_View_Container_Relation_Item::TYPE_INDUSTRY
        );
    }

    $container->setRelationContainer($relationContainer);

    return $container;
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

5 / 327

---


```php
    /**
     * @param array $models
     * @param int $type
     */
    private static function addItems(array $models, $type)
    {
        foreach ($models as $model) {
            $item = new Search_View_Container_Relation_Item(
                $model, 
                $type, 
                true
            );

            self::$_relationContainer->addItem($item, $type);
        }
    }
}
```

Сегодня 2 февраля 2022 года. Как думаешь, спустя шесть лет, понимаю ли я хоть что-то, что 
такое Search\_View\_Container\_Relation\_Item? Нет, я понятия не имею, что это. Я знаю только 
одно наверняка: это мне не помогает. Этот проект о фрилансерах и проектах. Этот класс делает 
что-то, связанное с поиском проектов (я предполагаю), но он не раскрывает это намерение. Ты 
когда-нибудь слышал, чтобы менеджер продукта говорил: «Вау, мы получили так много 
положительных отзывов о функции Search View Container Factory Project»?

Может быть, если я отступлю на шаг назад и посмотрю на структуру файлов, я что-то пойму лучше.

Martin Joo — Предметно-ориентированное проектирование с Laravel

6 / 327

---

И вот пример структуры файлов того старого проекта (именно та, что путает и не раскрывает сути):

```
classes git:(master) tree ./Search

./Search
├── Complex
│   └── Project.php
├── Factory
│   └── Project.php
├── Relation
│   └── Factory
│       └── Project.php
├── Simple
│   └── Project.php
└── View
    └── Container
        ├── Factory
        │   └── Project.php
        ├── Project.php
        └── Relation
            └── Project.php

9 directories, 7 files
```

Нет, всё равно понятия не имею. Вот моя мысль:

Технические термины и чрезмерно используемые шаблоны — отстой, когда речь идёт о высокоуровневых бизнес-приложениях.

Так что стратегическое проектирование — это всё о том, как **не** строить проекты вроде этого. А техническое проектирование даёт тебе некоторые полезные инструменты, чтобы этого добиться. На следующих страницах мы поговорим о следующих концепциях:

**Объекты-значения (Value Objects)**

---

**Объекты передачи данных (Data Transfer Objects)**
**Репозитории (Repositories)**
**Пользовательские построители запросов (Custom Query Builders)**
**Сервисы (Services)**
**Действия (Actions)**
**View Models (View Models)**
**CQRS (CQRS)**
**Состояния и переходы (States and Transitions)**
**Домены и приложения (Domains and Applications)**

Martin Joo — Предметно-ориентированное проектирование с Laravel

8 / 327

---

**Работа с данными**

Работа с данными — один из самых критически важных аспектов любого бизнес-приложения.
К сожалению, PHP не слишком хорош в этом плане. На мой взгляд, одна из лучших и худших особенностей PHP — это массивы. Особенно ассоциативные массивы. Проблемы такие:

* Нет type-hints (подсказок типов)
* Не задокументированная структура
* Нет ограничений. Ты можешь положить модели продуктов, ID продуктов и массивы продуктов под один и тот же ключ.

Ассоциативные массивы — это большие неструктурированные куски данных. Не пойми меня неправильно: они могут быть полезны, но в то же время очень раздражают. Изначально PHP-массивы пытались решить все задачи: очереди, стеки, списки, хеш-таблицы и деревья. Всё. Но с его слабой типизацией поддерживать такие структуры данных крайне тяжело.

Если подумать, данные играют огромную роль в любом бизнес-приложении:

* Приходит запрос. Он содержит входящие данные.
* Бизнес-слой обрабатывает эти данные.
* Слой базы данных вставляет эти данные в БД.
* Возвращается ответ. Он содержит исходящие данные.

Так что тебе придётся работать с данными на каждом уровне приложения. К счастью, Laravel и DDD дают нам несколько очень умных концепций.

Martin Joo — Предметно-ориентированное проектирование с Laravel

9 / 327

# Объекты-значения (Value Objects)

Объект-значение — это элементарный класс, который содержит в основном (но не только) скалярные данные. То есть это обёрточный класс, который связывает воедино связанную информацию. Давай посмотрим пример:

```php
class Percent
{
    public readonly ?float $value;
    public readonly string $formatted;

    public function __construct(float $value)
    {
        $this->value = $value;

        if ($value === null) {
            $this->formatted = '';
        } else {
            $this->formatted = number_format(
                $value * 100, 2
            ) . '%';
        }
    }

    public static function from(?float $value): self
    {
        return new self($value);
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

10 / 327

Этот класс представляет значение процента. Этот простой класс даёт тебе три преимущества:

    * Он инкапсулирует логику, которая обрабатывает null-значения и представляет их в виде процентов.
    * У тебя всегда есть два знака после запятой (по умолчанию) в процентах.
    * Лучшие типы.

Важное замечание: бизнес-логика или вычисления не являются частью объекта-значения. Единственное исключение, которое я допускаю, — это базовое форматирование.

Под «лучшими типами» я имею в виду такие методы:

```php
private function averageClickRate(int $total): Percent
{
    return Percent::from(
        SentMail::whereClicked()->count() / $total
    );
}
```

Ты берёшь float-значение и превращаешь его в «первоклассного гражданина» с помощью объекта Percent. Тебе больше не нужно беспокоиться о том, возвращает ли метод в твоём приложении отформатированную строку или число с плавающей точкой. Каждое процентное значение отныне может быть выражено как объект Percent. Так ты знаешь, что он содержит и число с плавающей точкой, и отформатированное строковое значение.

Оригинальное определение объекта-значения утверждает ещё две вещи:

    * Он неизменяем. У тебя нет сеттеров, и есть только свойства только для чтения.
    * Он не содержит ID или любого другого свойства, связанного с идентификацией. Два объекта-значения равны, только если их значения совпадают.

Что ещё можно выразить как объект-значение? Почти всё. Вот несколько примеров:

    * Адреса. В e-commerce-приложении, где тебе нужно работать с доставкой, может быть очень полезно использовать объекты вместо строк. Ты можешь выразить каждую часть адреса как свойство:



Martin Joo — Предметно-ориентированное проектирование с Laravel

11 / 327

    * Город (City)
    * Почтовый индекс (ZIP code)
    * Строка 1 (Line 1)
    * Строка 2 (Line 2)

* Числа. Любое финансовое приложение может выиграть от использования объектов-значений при вычислении метрик или сравнении чисел. Ты можешь выразить очень высокоуровневые концепции, например, маржу (Margin).

    * Верхняя строка (Top Line, например, доход)
    * Нижняя строка (Bottom Line, например, чистая прибыль)
    * Маржа (Margin, конечно, в виде Percent)

* Адреса электронной почты (Email addresses)

* Или другие специфические для приложения концепции.

Давай рассмотрим пример с маржой подробнее:

```php
class Margin
{
    public function __construct(
        public readonly float $topLine,
        public readonly float $bottomLine,
        public readonly float $margin,
    ) {}
}
```

Предположим, ты работал с финансовыми приложениями, которые имеют дело с публичными компаниями. Ты знаешь, что такие числа, как доход, даются в миллионах (или миллиардах в некоторых случаях, например, рыночная капитализация). Так что когда ты запрашиваешь доход Apple (который на момент написания составляет 378 миллиардов) из финансового API, ты получаешь не 378,323,000,000, а 378,323. И мы можем выразить это в коде так же:


Martin Joo — Предметно-ориентированное проектирование с Laravel

12 / 327


```php
class Margin
{
    public function __construct(
        public readonly Millions $topLine,
        public readonly Millions $bottomLine,
        public readonly Percent $margin,
    ) {}
}

И мы можем использовать класс `Margin` вот так:

class MetricsService
{
    public function profitMargin(IncomeStatement $incomeStatement): Margin
    {
        return new Margin(
            topLine: $incomeStatement->revenue,
            bottomLine: $incomeStatement->net_profit,
            margin: new Percent(
                $incomeStatement->net_profit->value / 
                $incomeStatement->revenue->value
            ),
        );
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

13 / 327

В этом примере я предполагаю, что `revenue` и `netProfit` — это экземпляры `Millions`.
Но разве `IncomeStatement` не является Eloquent-моделью?
Рад, что ты спросил. Да, является. И мы можем написать каст (преобразователь), который конвертирует `float` в `Millions`:

```php
class MillionsCast implements CastsAttributes
{
    /**
     * @param float $value
     */
    public function get($model, $key, $value, $attributes)
    {
        return new Millions($value);
    }

    /**
     * @param Millions $millions
     */
    public function set($model, $key, $millions, $attributes)
    {
        return [
            $key => $millions->value,
        ];
    }
}
```

Он может использоваться в Eloquent-модели, и вот как это работает:

* Когда ты обращаешься к атрибуту модели, вызывается метод `get`. Так, `$incomeStatement->revenue` вернёт экземпляр `Millions`.
* Когда ты задаёшь атрибут модели, вызывается метод `set`. Так, `$incomeStatement->revenue = new Millions(1000)` вставит свойство `value` (1000) из экземпляра `Millions`.


Martin Joo — Предметно-ориентированное проектирование с Laravel

14 / 327

Последняя часть — это использование каста в модели:

```php
protected $casts = [
    'revenue' => MillionsCast::class,
    'net_profit' => MillionsCast::class,
];
```

Итак, в двух словах, вот как использовать объект-значение. Подведём итог:

**Используя объекты-значения, ты можешь создавать объекты из связанного скалярного набора данных.**

Основные преимущества:

    * Это делает твой код более высокоуровневым.
    * Это проясняет вещи и помогает избежать путаницы. Например, теперь ты точно знаешь, что `Millions` содержит число, представленное в миллионах.
    * Это помогает работать с nullable-значениями. Тебе больше не нужно писать `?float $revenue`. Ты можешь писать `Millions $revenue`.

В введении я писал, что данные — это ключевая часть любого приложения. Я дал тебе такой список:

    * Приходит запрос. Он содержит входящие данные.
    * **Бизнес-слой обрабатывает эти данные.**
    * **Слой базы данных вставляет эти данные в БД.**
    * Возвращается ответ. Он содержит исходящие данные.

Как ты можешь видеть на примерах с кастом и другими, объект-значение используется в основном внутри (но не исключительно!) нашего приложения. В следующей главе мы обсудим, что происходит на границах (запросы и ответы).

Martin Joo — Предметно-ориентированное проектирование с Laravel

15 / 327

# Объекты передачи данных (Data Transfer Objects)

Следующая важная концепция — это объект передачи данных, или DTO. Это тоже простая концепция: это класс, который хранит данные. Эти данные затем передаются между компонентами. Что это за компоненты?

    * Твоё приложение в целом
    * Классы внутри твоего приложения

Давай посмотрим на прямолинейный пример:

```php
class CourseController extends Controller
{
    public function store(Request $request): Course
    {
        $course = Course::create($request->course);

        foreach ($request->lessons as $lesson) {
            // $lesson is an array
            $course->lessons()->create($lesson);
        }

        foreach ($request->student_ids as $studentId) {
            $course->students()->attach($studentId);
        }

        return $course;
    }
}
```

Это, конечно, чрезмерно упрощённый пример. Я работаю над системой e-learning, и можешь мне поверить, запрос на создание нового курса просто перегружен.


Martin Joo — Предметно-ориентированное проектирование с Laravel

16 / 327

Со временем это действие станет более сложным, и ты захочешь его рефакторить. Давай вынесем это в сервис (позже мы подробнее поговорим о сервисах. Пока что: это класс, который реализует некоторую бизнес-логику):

```php
class CourseService
{
    public function create(array $data): Course
    {
        $course = Course::create($data);
        $this->createLessons($course, $data['lessons']);
        $this->addStudents($course, $data['student_ids']);

        return $course;
    }

    public function createLessons(
        Course $course, 
        array $lessons
    ): void {
        foreach ($lessons as $lesson) {
            // $lesson is an array
            $course->lessons()->create($lesson);
        }
    }

    public function addStudents(
        Course $course, 
        array $studentIds
    ): void {
        foreach ($studentIds as $studentId) {     
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

17 / 327

```php

               $course->students()->attach($studentId);
        }
    }
}
```  

Выглядит нормально, но видишь проблемы?

    * Аргументы вроде этих: `array $data` или `array $lessons`
    * Строки вроде этой: `$data['lessons']`

Моя самая большая проблема — я не хочу поддерживать и отлаживать огромные ассоциативные массивы через пять лет.

Приведённый выше пример очень базовый. А теперь, пожалуйста, представь свой любимый легаси-проект, где тебе приходится работать с методами вроде этого:

```php
public function createProduct(array $data)
{
    // Вставь здесь 673 строки кода

    /**
     * Тебе придётся провести реверс-инжиниринг всего этого бардака,
     * просто чтобы понять, какую форму имеет $data, верно?
     */
}
```

DTO могут решить эту проблему, структурируя твои неструктурированные данные. Тот же `CourseService` с DTO:


Martin Joo — Предметно-ориентированное проектирование с Laravel

18 / 327

```php
class CourseService
{
    public function create(CourseData $data): Course
    {
        $course = Course::create($data->all());
        $this->createLessons($course, $data->lessons);
        $this->addStudents($course, $data->student_ids);

        return $course;
    }

    /**
     * @param Collection<LessonData> $lessons
     */
    public function createLessons(
        Course $course, 
        Collection $lessons
    ): void {
        foreach ($lessons as $lesson) {
            // $lesson is an instance of LessonData
            $course->lessons()->create($lesson);
        }
    }

    public function addStudents(
        Course $course, 
        Collection $studentIds
    ): void {
        foreach ($studentIds as $studentId) {
            $course->students()->attach($studentId);
        }
    }
}        
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

19 / 327

Теперь вместо массивов у нас есть такие объекты, как `CourseData` и `LessonData`. Давай заглянем внутрь `CourseData`:

```php
class CourseData
{
    public function __construct(
        public readonly ?int $id,
        public readonly string $title,
        public readonly string $description,
        /** @var Collection<LessonData> */
        public readonly Collection $lessons,
        /** @var Collection<int> */
        public readonly Collection $student_ids,
    ) {}

    public static function fromArray(array $data): self
    {
        $lessons = collect($data['lessons'])
            ->map(fn (array $lesson) => 
                LessonData::fromArray($lesson));

        return new self(
            Arr::get($data, 'id'),
            $data['title'],
            $data['description'],
            $lessons,
            $coolect($data['students_ids']),
        );
    }
}            
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

20 / 327

Единственное место, где тебе придётся иметь дело с массивами при таком подходе — это сам DTO. Только фабричная функция будет знать что-либо об уродливом массиве `$data`. Каждый слой твоего приложения будет использовать структурированный, типизированный объект.

Как видишь, этот класс не взаимодействует с `Request` или любым другим классом, зависящим от окружения, так что ты можешь использовать DTO где угодно, включая:

    * Контроллеры
    * Консольные команды
    * Сервисы или действия (рассмотрим позже в книге)
    * Модели или Query Builders (рассмотрим позже в книге)

И вот как ты можешь использовать его из `CourseController`:

```php
class CourseController extends Controller
{
    public function store(
        Request $request, 
        CourseService $courseService
    ): Course {
        return $courseService->create(
            CourseData::fromArray($request->all())
        );
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

21 / 327

Я думаю, это гораздо лучший подход, особенно в больших проектах. Но теперь у нас появляется другая проблема. Просто представь, сколько классов нам нужно создать, чтобы хранить курс:

    * `CreateCourseRequest`
    * `CourseData`
    * `CourseResource`
    * `LessonData`
    * `LessonResource`
    * Пара объектов-значений тут и там

И в этом примере у нас только две модели! А что если доменная модель этой функции будет намного сложнее? Ты быстро можешь оказаться с 10-15 классами только для реализации CRUD-функциональности для курсов. Это не конец света, но может быть очень раздражающим. К счастью, у нас есть элегантное решение. Но сначала давай подытожим, что такое DTO:

    * Это объект, который хранит и передаёт данные модели.
    * Его можно использовать внутри приложения между компонентами. Как в примере, когда мы создаём DTO в контроллере из запроса и передаём его в сервис.
    * Но его также можно использовать снаружи приложения. Так что вместо того чтобы иметь отдельный request, resource и DTO для курса, почему бы просто не иметь один DTO, чтобы править всеми?

Встречай пакет **laravel-data** от Spatie. Ты можешь использовать один DTO, который будет:

* Request (с правилами валидации)
* Resource
* И простым DTO

Важное замечание: если ты хочешь использовать DTO, тебе не обязательно брать laravel-data. Ты можешь писать чистые PHP-объекты, и у тебя всё будет нормально. Но я нахожу этот пакет настолько полезным, что не могу представить себе большой проект без него.
[https://spatie.be/docs/laravel-data/v1/introduction](https://spatie.be/docs/laravel-data/v1/introduction)


Вот как выглядит DTO laravel-data:


Martin Joo — Предметно-ориентированное проектирование с Laravel

22 / 327

```php
class SubscriberData extends Data
{
    public function __construct(
        public readonly ?int $id,
        public readonly string $email,
        public readonly string $first_name,
        public readonly ?string $last_name,
        /** @var DataCollection<TagData> */
        public readonly null|Lazy|DataCollection $tags,
        public readonly null|Lazy|FormData $form,
    ) {}
}
```

Основы очень похожи на чистый PHP DTO, но у нас есть эта штука `Lazy`. Я расскажу о ней позже, но она очень похожа на метод `whenLoaded`, используемый в Laravel resources (он помогает избегать проблем с запросами N+1).
Итак, у нас есть подписчик с вложенной коллекцией `TagData` и вложенным свойством `FormData`.

Этот пакет может автоматически создавать DTO из запроса. Так как его можно использовать как request, мы можем определить правила валидации:


Martin Joo — Предметно-ориентированное проектирование с Laravel

23 / 327

public static function rules(): array
{
    return [
        'email' => [
            'required',
            'email',
            Rule::unique('subscribers', 'email')
                ->ignore(request('subscriber')),
        ],
        'first_name' => ['required', 'string'],
        'last_name' => ['nullable', 'sometimes', 'string'],
        'tags' => ['nullable', 'sometimes', 'array'],
        'form_id' => ['nullable', 'sometimes', 'exists:forms,id'],
    ];
}

Мы также можем указать, как хотим, чтобы пакет создавал `SubscriberData` из HTTP-запроса:

```php


public static function fromRequest(Request $request): self
{
    return self::from([
        ...$request->all(),
        'tags' => TagData::collection(
            Tag::whereIn('id', $request->collect('tags'))->get()
        ),
        'form' => FormData::from(Form::find($request->form_id)),
    ]);
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

24 / 327

Ты видишь, что я запускаю некоторые запросы к БД, чтобы получить теги и форму. Так что вместо ID (которые приходят из запроса), у меня есть модели, которые могут быть отображены на `TagData` или `FormData`. Позже я объясню эти вещи подробнее.

И посмотри на контроллер:

```php
class CreateSubscriberController extends Controller
{
    public function __invoke(SubscriberData $data): SubscriberData
    {
        return SubscriberData::from(
            CreateSubscriberAction::execute($data)
        );
    }
}
```

Ты можешь внедрить любой класс `Data`, и преобразование из запроса произойдёт автоматически! И, как ты видишь, объект `Data` может быть возвращён из действия контроллера и будет преобразован в JSON (включая вложенные свойства).

На мой взгляд, это потрясающий инструмент, поэтому я буду активно использовать его в демонстрационном приложении позже.

Ещё один вопрос, чтобы завершить эту главу:
В чём разница между объектами-значениями (value objects) и DTO?

    * DTO имеет ID, потому что он представляет модель.
    * Объект-значение никогда не имеет ID. Он представляет значение, а не сущность.

Это главное различие. Однако в Laravel-сообществе я часто вижу, что люди путают эти две концепции. Ты даже можешь встретить людей, которые пишут только value objects и используют их как DTO и как VO.


Martin Joo — Предметно-ориентированное проектирование с Laravel

25 / 327

И знаешь что? **На мой взгляд, это абсолютно нормально**.

Конечно, эти правила важны, но я не вижу их как строгие правила, которым ты обязан следовать, если хочешь заниматься DDD. Я скорее вижу их как **рекомендации**. Например, позже в демонстрационном приложении я использую DTO вместо объекта-значения, потому что в данной ситуации это гораздо удобнее.

Martin Joo — Предметно-ориентированное проектирование с Laravel

26 / 327


Теперь, когда мы разобрались с данными, можем перейти к базе данных.
Куда помещать запросы? Как структурировать код? Мы все задавали себе эти вопросы, и вот ответ: **никто точно не знает**. Это различается для каждого проекта и каждой команды.

Один из способов организовать запросы — использовать репозитории. Это спорная тема в Laravel- и PHP-сообществе. Я не буду использовать их в демонстрационном приложении, но это концепция из DDD, и, если честно, неплохая. В конце этой главы я покажу тебе Laravel-эквивалент паттерна репозитория.

Вот пример класса-репозитория:

```php
class ProductRepository
{
    public function create(ProductData $data): Product
    {
        Product::create($data->all());
        // Другое связанное с БД
    }

    public function search(
        PriceRange $priceRange, 
        string $searchTerm
    ): Collection {
        return Product::query()
            ->whereBetween('price', [
                $priceRange->low, 
                $priceRange->high
            ])
            ->where('name', 'like', "%{$searchTerm}%")
            ->limit(10)
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

27 / 327

```php
        ->get();
    }
```
Это класс для твоих запросов к базе данных. Вот и всё.
Вместо того чтобы писать запросы прямо в контроллерах или моделях, ты переносишь их в репозиторий. Обычно у каждой модели есть свой репозиторий, но это не всегда обязательно.

Ты можешь использовать его так:

```php
class ProductSearchController extends Controller
{
    public function index(
        Request $request, 
        ProductRepository $products
    ) {
        return $products->search(
            PriceRange::from($request), 
            $request->search_term
        );
    }
}
```

Так что кажется, что это хорошая концепция. Почему же её ненавидят? Есть несколько проблем:

* Обычно у каждой (или почти каждой) модели есть репозиторий, как `ProductRepository` в этом примере. Так что ты буквально просто перемещаешь запрос из одного места в другое — из модели в репозиторий. Через шесть месяцев разработки `ProductRepository` превратится в монстра на 5000 строк. Ровно как и сама модель `Product` превратилась бы в монстра на 5000 строк.
* По определению, используя классы-репозитории, каждый запрос к базе данных должен оказываться внутри них. Так что тебе придётся переносить туда даже одноразовые запросы. Ты быстро окажешься с…



Martin Joo — Предметно-ориентированное проектирование с Laravel

28 / 327

…классом, содержащем методы, которые используются один раз во всём приложении.
* Если ты не кладёшь каждый запрос в репозиторий, тогда зачем вообще использовать репозитории? В этом случае ты в итоге получаешь несогласованную структуру: часть запросов остаётся в контроллерах или моделях, а другая часть живёт в репозитории. По моему опыту, это не оптимальное решение.
*Лично для меня: я не чувствую, что `$products->search()` или `$this->products->getById($id)` хорошо вписываются в Laravel.

Однако у репозиториев есть и хорошие стороны:

* Тебе не нужно иметь один репозиторий на каждую модель.
  Представь, у тебя большой корпоративный проект с 200+ таблицами. Один «модуль» или набор функций — это очень простой трекер задач. Этот модуль требует всего шесть таблиц и 500 строк кода, связанного с базой данных. Тебе не нужно размазывать эти 500 строк по шести репозиториям (как ты сделал бы с моделями). Ты можешь написать только один класс, называемый `IssueTrackerRepository`. С моделями ты так не сделаешь. Думаю, это может быть полезно в некоторых ситуациях.

Честно говоря, это единственное преимущество, которое я могу придумать.
Если ты уже знаком с DDD, ты, вероятно, слышал что-то вроде этого:
**паттерн репозитория абстрагирует хранилище данных и позволяет тебе заменить базу данных, не меняя бизнес-код**. Это правда.
Однако за последнее десятилетие я сталкивался с множеством странных запросов на доработки, но вот два запроса, которые ко мне никогда не поступали:

* Никто никогда не просил меня сменить язык программирования существующего проекта.
* Никто никогда не просил меня сменить движок базы данных под работающим проектом.

Так что я не могу честно говорить об этом как о преимуществе. При этом, я думаю, что репозитории бесполезны в большинстве ситуаций. На самом деле, Laravel предлагает лучшее решение: **пользовательские query builders**.

Martin Joo — Предметно-ориентированное проектирование с Laravel

29 / 327

# Пользовательские Query Builders

Сначала давай обсудим, что такое query builder. Когда ты пишешь что-то вроде этого:

```php
$query = Product::where(
    'name', 
    'Domain-Driven Design with Laravel'
);
```

ты взаимодействуешь с классом `Illuminate\Database\Eloquent\Builder`. Он содержит твои любимые Eloquent-методы, такие как `where`, `firstWhere`, `latest` и т. д.

Но в Laravel мы не пишем код вот так напрямую:

```php
Builder::where('description', 'LIKE', "%{$searchTerm}%");
```

Мы вызываем метод `where` на классах-моделях (`Model`). Так что должна быть какая-то связь между `Model` и `Builder`. Эта связь — метод `newEloquentBuilder` в базовом классе `Model`:

```php
/**
 * Create a new Eloquent query builder for the model.
 *
 * @param  \Illuminate\Database\Query\Builder  $query
 * @return \Illuminate\Database\Eloquent\Builder|static
 */
public function newEloquentBuilder($query)
{
    return new Builder($query);
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

30 / 327

Он возвращает новый экземпляр `Builder`, и каждый раз, когда ты взаимодействуешь со своей моделью, этот экземпляр будет использоваться.
Так что, когда ты вызываешь `Product::where`, метод `newEloquentBuilder` будет вызван, и он вернёт новый `Builder`.

Мы можем расширить этот базовый класс `Builder` и создать собственный query builder:

Это пользовательский билдер для модели `Mail`. Метод `whereOpened` может использоваться как scope.
На самом деле, scopes моделей — это просто синтаксический сахар. Так что этот метод можно использовать так:

```php
Mail::whereOpened()->get();
Mail::whereOpened()->where('title', 'First Mail')->get();
```

В билдере мы должны возвращать `self`, чтобы можно было цеплять Eloquent-методы:

```php
class MailBuilder extends Builder
{
    public function whereOpened(): self
    {
        return $this->whereNotNull('opened_at');
    }
}
```

Однако тебе не обязательно писать методы вроде scopes. В query builder ты можешь делать (почти) всё что угодно.

Martin Joo — Предметно-ориентированное проектирование с Laravel

31 / 327

```php
class DividendPayoutBuilder extends Builder
{
    public function sumByDate(
        DateFilter $dates, 
        User $user
    ): float {
        return $this->whereBelongsTo($user)
            ->wherePayedBetween($dates)
            ->sum('amount');
    }
}

$dividendThisMonth = 
    DividendPayout::sumByDate(DateFilter::thisMonth());
```    

Этот метод нельзя цеплять, потому что он возвращает `float`. Последний кусочек пазла — это сказать Laravel, что мы хотим использовать **свой** query builder. Это можно сделать, переопределив метод `newEloquentBuilder` в твоей модели:    

```php
class Mail extends Model
{
    public function newEloquentBuilder($query): MailBuilder
    {
        return new MailBuilder($query);
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

32 / 327

И всё! Query builder — это Laravel-эквивалент репозитория, если задуматься. Но, на мой взгляд, он гораздо больше «по-ларевеловски». Подведём итог:

* Я предпочитаю query builders вместо репозиториев.
* Обычно я пишу scopes и часто используемые методы в билдеры.
* Но я **не** кладу каждый запрос в билдеры.

Таким образом, модели остаются очень простыми и «тонкими». Позже я расскажу, куда класть одноразовые запросы.

Martin Joo — Предметно-ориентированное проектирование с Laravel

33 / 327

# Сервисы

Класс-сервис значит много разных вещей для разных разработчиков. Но в общем: это класс, который содержит некоторую бизнес-логику. Например:

```php
class TodoNotificationService
{
    public function sendDueTodayNotifications(): void
    {
        Todo::whereDueToday()
            ->get()
            ->each(fn (Todo $todo) => $todo->user->notify(
                new DueTodayNotification($todo)
            ));
    }
}

```
Сервисы часто используются для обёртки внешних сервисов, таких как Github, Twilio и других.
Но они могут быть и более низкоуровневыми, вроде этого:

```php
class TodoService
{
    public function create(TodoData $data): Todo
    {
        $todo = Todo::create($data->all());
        // ...
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

34 / 327

* Так можно ли использовать сервисы как репозитории?Теоретически — нет, но на практике — да.  И многие разработчики действительно используют сервисы вместо репозиториев.
* Можно ли использовать сервисы вместе с репозиториями?
Да, но я **не рекомендую** этот подход.

Когда у тебя в проекте есть и репозитории, и сервисы, основная идея такая:

* Каждая модель имеет свой репозиторий.
* Репозитории содержат запросы к базе данных.
* При необходимости ты создаёшь сервис для модели (или набора моделей, как мы обсуждали в главе о репозиториях). Например, у класса `Todo` есть более сложная логика уведомлений, поэтому ты можешь добавить `TodoNotificationService`.

Этот подход вполне нормальный и может работать, но вот главная проблема:

* Ты в итоге получаешь **несогласованные классы**. Когда ты работаешь с моделью `Todo`, у тебя есть и репозиторий, и сервис. Но когда ты работаешь над функцией, связанной с `Project`, у тебя есть только репозиторий, потому что проект не требует сервисного класса.
И в случае с `Todo` ты не сможешь быстро сказать, живёт ли метод в сервисе или в репозитории.
* В общем, твои фичи размазаны между сервисами и репозиториями, и становится чуть сложнее ими управлять.

Это не очень объективно, так что для тебя, может, это сработает прекрасно!
**А вот для меня — я придерживаюсь действий (actions).**

Martin Joo — Предметно-ориентированное проектирование с Laravel

35 / 327

# Действия (Actions)

А что, если мы можем объединить репозитории и сервисы?
Наверное, у нас получится большой бардак, как жирный контроллер, который делает всё подряд, верно? Да, это правда.
Но давай на минуту забудем о технических обязанностях. В первой главе я писал, что технический код — это отстой в бизнес-приложении. Думаю, именно поэтому мне не нравится, когда репозитории и сервисы используются вместе.

А что, если мы определим ответственность **на основе фич**, а не технических вещей?
Теперь у нас есть чистый, переиспользуемый класс action:

```php
class CreateTodoAction
{
    public function execute(TodoData $data): Todo
    {
        $todo = Todo::create($data->all());

        if (!$todo->creator->is($todo->assignee)) {
            $todo->assignee->notify(
                new TodoAssignedNotification($todo)
            );
        }

        $todo->watchers->each(fn (User $watcher) => 
            $watcher->notify(new TodoCreatedNotification($todo))
        );

        return $todo;
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

36 / 327

Классы-действия (Action classes) имеют несколько серьёзных преимуществ:

* **Single responsibility** (единственная ответственность). Каждое действие отвечает ровно за одну вещь, например, создание задачи (todo).
* **Self-contained** (самодостаточность). Действие выполняет задачу от начала до конца.
* **Nesting** (вложенность). Действие может вызывать другое действие. Если создание задачи — это сложная задача, возможно, есть смысл вынести логику уведомлений.
* **Queueable** (может быть поставлено в очередь). Не по умолчанию, но с помощью пакета Spatie `laravel-queueable-action`.
[https://github.com/spatie/laravel-queueable-action](https://github.com/spatie/laravel-queueable-action)
* Но вот самое важное: **твои действия описывают пользовательские истории (user stories)**.
Таким образом, они сближают твой код с бизнес-языком. Просто взгляни на это:

Martin Joo — Предметно-ориентированное проектирование с Laravel

37 / 327

Если в твою команду приходит новый разработчик, он/она сразу поймёт, что твоё приложение умеет делать с подписчиками:

* Создавать подписчика
* Фильтровать подписчиков
* Импортировать подписчиков

Не нужно глубоко копаться в контроллерах, моделях или сервисах. Всё чисто и понятно. На мой взгляд, это **огромный плюс**.
Вдобавок, действия (actions) широко используются в Laravel-сообществе. Кстати, эти примеры взяты из демонстрационного приложения, которое мы будем строить на протяжении всей книги. Как видишь, нас ждёт **много action**.

Есть ещё одна деталь, которую мы можем обсудить. Существует три способа писать функции в action-классе.

---

**Нестатический метод `execute`**
Это самый очевидный выбор, и ты не ошибёшься, используя его. Я применял его в предыдущих примерах.

---

**Вызов класса как `invokable`**
В этом случае ты можешь написать класс вот так:

```php
class CreateTodoAction
{
    public function __invoke(TodoData $data): Todo
    {
        // ...
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

38 / 327

```php
class TodoController
{
    public function store(
        Request $request, 
        CreateTodoAction $createTodoAction
    ) {
        $todo = $createTodoAction(TodoData::from($request));
    }
}
```

Как видишь, action можно вызывать точно так же, как функцию. Это тоже хороший вариант, потому что actions выглядят иначе, чем любой другой класс, и ты сразу понимаешь, что это action.

Однако бывают случаи, когда ты не можешь внедрить action в метод, а только в конструктор. Например, когда ты используешь один action внутри другого:

```php
class CreateTodoAction
{
    public function __construct(
        private readonly NotifyUsersAction $notifyUsersAction
    ) {}

    public function __invoke(TodoData $data): Todo
    {
        $todo = Todo::create($data->toArray());
        ($this->notifyUsersAction)($todo);
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

39 / 327

Как видишь, тебе нужно оборачивать action в скобки. И мне, честно говоря, не очень нравится, как это выглядит, поэтому обычно это не мой основной подход.

**Статический метод `execute`**

В этом подходе все функции `execute` являются статическими:

```php
class CreateTodoAction
{
    public static function execute(TodoData $data): Todo
    {
        // ...
    }
}

class TodoController
{
    public function store(Request $request)
    {
        $todo = CreateTodoAction::execute(
            TodoData::from($request)
        );
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

40 / 327

Это мой любимый вариант, потому что он просто выглядит аккуратно!
Но если ты хочешь писать тесты, которые мока́ют (заменяют) actions, это плохой выбор, потому что сделать это не так просто (а может, вообще невозможно — я не уверен).
Однако для меня это не проблема, потому что я пишу API-тесты, поэтому я **не** мокаю actions. Я мокаю только внешние зависимости, такие как сторонние API.
В этой книге я буду использовать именно этот подход, и ты увидишь, насколько чисто выглядит код.

Ты можешь ошибаться, если думаешь, что actions — это не часть DDD, а просто какая-то современная «магия Laravel».
Впервые я услышал об actions от Роберта С. Мартина в его книге **«Agile Software Development»**, написанной в 2002 году (за 10 лет до рождения Laravel).
В той книге они назывались **transactions**.
После этого я снова встретил их в мире C#, где их называли **commands**.
Кстати, это и есть первая буква в **CQRS** (подробнее об этом позже).
После всего этого появился пакет MediatR (2015), где actions назывались **requests**.
Как видишь, actions имеют долгую историю, и Laravel-сообщество их не изобретало.
Однако «action» — это самое крутое название, которое я когда-либо слышал для описания класса.

Martin Joo — Предметно-ориентированное проектирование с Laravel

41 / 327

# ViewModels

ViewModel — это очень умный способ обработки данных, связанных с отображением (view).
Но в этом контексте я говорю **не только** о Blade-шаблонах.
Можно думать о view model как о контейнере данных, который отвечает на конкретный запрос. Их можно использовать как в SPA (включая Inertia.js), так и в полноценных MVC-приложениях.

Допустим, мы работаем над страницей отчёта, где нужно показать данные, связанные с доходами, например:

* Общий доход
* Общее количество клиентов
* Средний доход на клиента

Этот пример может использовать (сильно упрощённый) view model вот так:

```php
class GetRevenueReportViewModel extends ViewModel
{
    public function totalRevenue(): int
    {
        return Order::sum('total');
    }

    public function totalNumberOfCustomers(): int
    {
        return Order::query()
            ->groupBy('customer_id')
            ->count('customer_id');
    }
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

42 / 327

```php
    public function averageRevenuePerCustomer(): int
    {
    return $this->totalRevenue() / $this->totalNumberOfCustomers();
    }
}
```

ViewModel реализует (или вызывает из query builder) каждый запрос, который нужна страница или ответ.
Его можно использовать в контроллерах вот так:

```php
class RevenueReportController extends Controller
{
    public function index()
    {
        return new GetRevenueReportViewModel();
    }
}
```

Но как мы можем получить JSON-ответ от класса, который содержит только методы?
Базовый класс `ViewModel` реализует интерфейс Laravel `Arrayable` и вернёт массив вот такого вида:

```php
[
    'total_revenue' => 24500,
    'total_number_of_customers' => 2311,
    'average_revenue_per_customer' => 10.60,
]
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

43 / 327

Таким образом, метод с названием `totalRevenue` становится ключом массива `total_revenue`, и Laravel преобразует этот массив в JSON.
Позже я покажу точный код, который делает эту магию (5 строк с использованием Reflection).

Подожди минутку! Раньше ты сказал, что мы будем использовать DTO как ответы, не так ли?
Да, это правда, поэтому в демонстрационном приложении вместо `int`-значений я буду использовать DTO.
Быстрый пример:

```php
class GetDashboardViewModel extends ViewModel
{
    public function newSubscribersCount(): NewSubscribersCountData
    {
        return new NewSubscribersCountData(
            today: Subscriber::whereSubscribedBetween(
                DateFilter::today()
            )->count(),

            thisWeek: Subscriber::whereSubscribedBetween(
                DateFilter::thisWeek()
            )->count(),

            thisMonth: Subscriber::whereSubscribedBetween(
                DateFilter::thisMonth()
            )->count(),

            total: Subscriber::count(),
        );
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

44 / 327

Это страница дашборда, и, как видишь, я упаковываю числа вместе в DTO и возвращаю этот DTO из ViewModel. Ответ выглядит вот так:

```json
{
  "new_subscribers_count": {
    "today": 4,
    "this_week": 39,
    "this_month": 104,
    "total": 341
  }
}
```

---

ViewModel могут помочь твоему проекту двумя способами:

* Твой код становится на шаг ближе к доменному языку. Так что когда продакт-менеджер говорит «на странице дашборда», ты сразу понимаешь, что речь идёт о `GetDashboardViewModel`.
* Это отличное дополнение — иметь точную структуру своего UI, выраженную через классы.

Позже, в демонстрационном приложении, мы будем использовать Inertia, а также API, так что ты увидишь, как писать эти классы для обеих ситуаций (**спойлер: одинаково**).

Теперь, когда мы узнали об actions и view models, можем перейти к загадочному CQRS.

Martin Joo — Предметно-ориентированное проектирование с Laravel

45 / 327

**CQRS**

CQRS — это, на мой взгляд, один из самых переусложнённых и неправильно понятых аспектов DDD, так что давай разберёмся!
Это означает **Command and Query Responsibility Segregation** (разделение ответственности команд и запросов). Сложное название, давай посмотрим, что означают эти слова:

* **Команда (command)** — это операция записи, например создание нового продукта.
* **Запрос (query)** — это операция чтения, например получение всех продуктов.
* **Разделение ответственности** означает, что мы должны разделить эти два типа функций.

Так что вот такой простой класс **не удовлетворяет CQRS**:

```php
class ProductService
{
    public function create(ProductData $data): Product
    {
        // ...
    }

    public function getAll(): Collection
    {
        // ...
    }
}
```

Я не думаю, что с таким классом что-то не так; на самом деле, он может быть **лучшим** решением во многих проектах.

---

Так как же применять CQRS? Если подумать о предыдущих разделах, у нас есть схожие концепции с командами и запросами. Единственное отличие — это название:

* **Actions** играют роль команды или операции записи.
* **ViewModels** играют роль запроса или операции чтения.

Martin Joo — Предметно-ориентированное проектирование с Laravel

46 / 327

Как видишь, применить CQRS с помощью этих двух классов **очень, очень просто**.
Оказалось, что я использовал CQRS за годы до того, как вообще узнал, что это такое.
Так что я не продвигаю идею CQRS как отдельный паттерн; мне просто нравится работать с actions и view models.
Также я не думаю, что это нужно для **каждого** приложения, но это даёт отличные преимущества:

* Твой код становится более понятным.
* У тебя маленькие, более простые для поддержки классы.
* Это даёт идеальное разделение обязанностей.
* Каждый класс имеет одну хорошо определённую ответственность.

Вот что такое CQRS.
Однако, если ты начнёшь гуглить статьи и туториалы по этой теме, ты найдёшь **очень сложные** объяснения.
Они часто показывают, как CQRS используется с другими более сложными концепциями, такими как:

* event sourcing,
* event stores,
* отдельные базы данных для чтения и записи.

В этой книге я **не** буду говорить про event sourcing по трём причинам:

1. Я сам его не использую, поэтому не считаю себя вправе о нём писать.
2. Я не думаю, что он нужен большинству бизнес-приложений.
3. Он требует совершенно другой архитектуры и взгляда.

Так что очень маловероятно, что ты начнёшь рефакторить своё приложение под event sourcing после того, как узнаешь о нём.
Зато гораздо проще применить любые другие концепции, о которых мы говорим в этой книге.

CQRS может быть **сложнее** (и обычно бывает), чем я его здесь описываю.
Например, в мире C# разработчики используют так называемый **mediator**. Это способ реализовать синхронные сообщения внутри процесса.
По сути, это слой, который обрабатывает команды и запросы.
Если хочешь узнать больше, загляни сюда: [https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)

Кроме того, CQRS — это совсем другой (и сложный) зверь в мире микросервисов.
Там это означает, что у тебя есть отдельные сервисы и базы данных для чтения и записи.
В таком контексте **почти обязательно** использовать CQRS вместе с event sourcing и событийно-ориентированной асинхронной архитектурой.
Если тебе интересно, посмотри это видео (его можно понять даже без магистратуры по computer science):
[https://www.youtube.com/watch?v=uTCKzPg0Uak\&list=WL](https://www.youtube.com/watch?v=uTCKzPg0Uak&list=WL)

Martin Joo — Предметно-ориентированное проектирование с Laravel

47 / 327

# Состояния и переходы (States And Transitions)

**State** — это класс, который представляет состояние чего-то.
Это «что-то» в большинстве случаев — это Eloquent-модель.
То есть вместо строки у нас есть выделенный класс.

Как выглядит класс State?
Представим, что мы работаем над e-commerce приложением, и у нас есть класс `Order`.
У `Order` есть статус, например:

* Draft
* Pending
* Paid
* PaymentFailed

Для простоты давай скажем, что самая критичная бизнес-логика, связанная со статусом заказа, — это возможность его изменить.
Покупатель может изменить заказ в статусе Draft, но **не может** изменить заказ со статусом Paid.

Сначала создадим абстрактный класс:

```php
abstract class OrderStatus
{
    public function __construct(protected Order $order)
    {
    }

    abstract public function canBeChanged(): bool;
}
```

Каждое состояние будет расширять родительский класс `OrderStatus`. Теперь мы можем создать конкретные классы.

Martin Joo — Предметно-ориентированное проектирование с Laravel

48 / 327

```php
class DraftOrderStatus extends OrderStatus
{
    public function canBeChanged(): bool
    {
        return true;
    }
}
```

Заказ в статусе Draft можно изменить, а в статусе Paid — нельзя:

```php
class PaidOrderStatus extends OrderStatus
{
    public function canBeChanged(): bool
    {
        return false;
    }
}
```

Чтобы сделать это ещё лучше, мы можем написать `Enum` с фабричной функцией, которая будет создавать эти классы статусов.

Martin Joo — Предметно-ориентированное проектирование с Laravel

49 / 327

Как видишь, этот enum работает как фабричная функция.
Это одна из скрытых фишек enum'ов в PHP 8.1.
В модели `Order` мы можем использовать это с помощью accessor'а атрибута:

```php
enum OrderStatuses: string
{
    case Draft = 'draft';
    case Pending = 'pending';
    case Paid = 'paid';
    case PaymentFailed = 'payment-failed';

    public function createOrderStatus(Order $order): OrderStatus
    {
        return match($this) {
            OrderStatuses::Draft => new DraftOrderStatus($order),
            OrderStatuses::Pending => new PendingOrderStatus($order),
            OrderStatuses::Paid => new PaidOrderStatus($order),
            OrderStatuses::PaymentFailed => new PaymentFailedOrderStatus($order),
        };
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

50 / 327

Это новый синтаксис accessor'а в Laravel 8; он эквивалентен вот этому:

```php
public function getStatusAttribute(string $value): OrderStatus
{
    return OrderStatuses::from($value)->createOrderStatus($this);
}
```

Сначала я создаю enum из строкового значения, сохранённого в базе данных; после этого вызываю фабричный метод на enum'е.
Таким образом, каждый раз, когда ты обращаешься к атрибуту `status` у заказа, ты получаешь экземпляр `OrderStatus`.

Теперь давай посмотрим, как использовать эти классы состояния:

```php
class Order extends Model
{
    public function status(): Attribute
    {
        return new Attribute(
            get: fn (string $value) =>
                OrderStatuses::from($value)->createOrderStatus($this),
        );
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

51 / 327


```php
class OrderController extends Controller
{
    public function update(
        UpdateOrderRequest $request, 
        Order $order
    ) {
        abort_if(!$order->status->canBeChanged(), 400);
    }
}
```
Или мы можем просто добавить метод-делегат в класс `Order`:

```php
class Order extends Model
{
    public function canBeChanged(): bool
    {
        return $this->status->canBeChanged();
    }
}
```

Теперь мы можем использовать это вот так:

```php
$order->canBeChanged();
```

Вместо:

```php
$order->status->canBeChanged();
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

52 / 327

Эта структура даёт тебе некоторые преимущества:

* **Инкапсуляция:** всё, что связано с состоянием, находится в одном месте.
* **Разделение ответственности:** каждое состояние имеет свой класс, так что разделение отличное.
* **Более простая логика:** нет необходимости в отвратительных конструкциях `if-else` или `switch` вокруг строкового атрибута.

---

Однако это может быть **существенным оверхедом**, если у тебя всего несколько состояний в модели, и они используются лишь для проверки базового поведения.

---

Двигаемся дальше: нам нужно поменять состояние с `Pending` на `Paid` в какой-то момент.
Думаю, мы все писали подобный код в прошлом:

```php
class OrderController extends Controller
{
    public function pay(PayOrderRequest $request, Order $order)
    {
        // Some logic here...
        $order->status = 'paid';
        $order->save();
    }
}
```

**Domain-Driven Design** учит нас следующему:
мы должны рассматривать такие переходы как **первоклассные сущности**.
Так что давай поместим их в отдельные классы!
Сначала мы можем создать некую абстракцию. В этом случае нам не нужен класс, а только интерфейс.

Martin Joo — Предметно-ориентированное проектирование с Laravel

53 / 327

```php
interface Transition
{
    /**
     * @throws Exception
     */
    public function execute(Order $order): Order;
}
```
**Переход (Transition)** можно выполнить. Он принимает `Order` и возвращает `Order`.
Если что-то пойдёт не так — он выбрасывает `Exception`. Это контракт.

Вот конкретный Transition:

```php
class DraftToPendingTransition implements Transition
{
    public function execute(Order $order): Order
    {
        if ($order->state::class !== DraftOrderStatus::class) {
            throw new Exception('Transition not allowed');
        }
        $order->status = PendingOrderStatus::class;
        $order->save();
        return $order;
    }
}
```

Сначала он проверяет, что текущий `Order` находится в состоянии `Draft` и обновляет его на `Pending`.
Также можно использовать PHP8 enum вместе со статусами и переходами.

Martin Joo — Предметно-ориентированное проектирование с Laravel

54 / 327