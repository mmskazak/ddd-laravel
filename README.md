**ПРЕДМЕТНО-ОРИЕНТИРОВАННОЕ**
**ПРОЕКТИРОВАНИЕ С**
**LARAVEL**

**МАРТИН ДЖО**

Единственный подход к проектированию, который вам нужен

---

**Основные понятия**

Domain-Driven Design
Работа с данными
Объекты-значения
Объекты передачи данных
Репозитории
Пользовательские построители запросов
Сервисы
Действия
ViewModels
CQRS
Состояния и переходы
Домены и приложения
Преимущества и недостатки

**Проектирование программного обеспечения для e-mail маркетинга**

Обзор
Подписчики
Рассылки
Последовательности
Автоматизации
Другие функции
Почему e-mail маркетинг?
Пользовательские истории
Моделирование данных
Подписчики
Рассылки
Отправленные письма
Короткое замечание о производительности
Последовательности
Автоматизации
Домены

**Создание программного обеспечения для e-mail маркетинга**

Настройка доменов и приложений
Подписчики
Создание нового подписчика
Обновление подписчика

Martin Joo — Предметно-ориентированное проектирование с Laravel

1 / 327

---

**View Models**
Vue Component
Получение подписчиков
Реальная мощь DTO и действий
Заключение

**Рассылки**
DTO рассылки
Обработка фильтров
Upserting рассылки
Фильтрация подписчиков
Отправка рассылки
Вычисление эффективности рассылки
Предпросмотр рассылки
Получение рассылок

**Последовательности**
Создание последовательности
Продвижение последовательности
Рефакторинг
Обновление статуса подписчика
Вычисление эффективности последовательности
Прогресс последовательности

**Панель и отчеты**
Количество новых подписчиков
Вся эффективность за все время

**Подписчики**
**Автоматизации**
Upserting автоматизаций
Запуск автоматизаций
Заключение

Спасибо

Martin Joo — Предметно-ориентированное проектирование с Laravel

2 / 327

---

**Основные понятия**
**Предметно-ориентированное проектирование**

Прежде всего, мы должны ответить на самый очевидный вопрос: что такое предметно-ориентированное проектирование (Domain-Driven Design, DDD)?

DDD — это подход к разработке программного обеспечения, который пытается максимально сблизить бизнес-язык и код. Это наиболее важный атрибут этого подхода. Но по какой-то причине DDD — одна из самых неправильно понятых и чрезмерно усложнённых тем в сообществе разработчиков, поэтому я постараюсь объяснить её просто.

DDD учит нас двум основным вещам:

**Стратегическое проектирование**
**Техническое проектирование**

По моему честному мнению, стратегическое проектирование гораздо важнее технических аспектов. Трудно подытожить это одной крутой фразой, но ты увидишь, что я имею в виду, в оставшейся части книги. Пока что это основные столпы:

* Домены и пространства имён. Позже я расскажу, что такое домен, но DDD учит нас структурировать код очень выразительно и логично.
* Выбор правильных названий. Например, если в бизнесе пользователей называют «клиентами» или «сотрудниками», ты должен переименовать свой класс User, чтобы следовать этой конвенции.
* Классы и объекты должны выражать заложенное в них намерение. В самом простом Laravel-приложении есть модели и контроллеры. Что ты думаешь, когда видишь проект с 50 моделями и 50 контроллерами? Ты видишь основную предметную область приложения, но тебе придётся копнуть глубже, если хочешь хорошо понимать функционал, верно? А как насчёт 300 моделей и 500 контроллеров? У тебя нет шансов осознать такое приложение.

В большинстве проектов разработчики предпочитают технические термины бизнес-концепциям. Это естественно. В конце концов, мы технические люди. Но у меня вопрос: действительно ли эти технические термины так важны?

Martin Joo — Предметно-ориентированное проектирование с Laravel

3 / 327

---

Позволь показать тебе пример. Это фрагмент из одного из моих приложений, которое я написал 28 октября 2016 года после того, как закончил книгу по шаблонам проектирования. Взгляни на него (это не Laravel):

```php
class Search_View_Container_Factory_Project
{
    /**
     * @var Search_View_Container_Relation_Project
     */
    private static $_relationContainer;

    /**
     * @param array $data
     * @return Search_View_Container_Project
     */
    public static function createContainer(array $data)
    {
        if ($data['current'] == 'complex') {
            return self::createComplex($data);
        } else {
            return self::createSimple($data);
        }
    }

    /**
     * @param array $data
     * @return Search_View_Container_Project
     */
    private static function createSimple(array $data)
    {
        $container = new Search_View_Container_Project('simple');
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

4 / 327

---

```php
    $container->setSearchTerm(
        Arr::get($data, 'search_term')
    );

    $relationContainer = new 
        Search_View_Container_Relation_Project();

    $industryModel = new Model_Industry();
    $industries = $industryModel->getAll();

    foreach ($industries as $industry) {
        $industryItem = new Search_View_Container_Relation_Item(
            $industry, 
            Search_View_Container_Relation_Item::TYPE_INDUSTRY, 
            false
        );

        $relationContainer->addItem(
            $industryItem, 
            Search_View_Container_Relation_Item::TYPE_INDUSTRY
        );
    }

    $container->setRelationContainer($relationContainer);

    return $container;
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

5 / 327

---

Сегодня 2 февраля 2022 года. Как думаешь, спустя шесть лет, понимаю ли я хоть что-то, что такое Search\_View\_Container\_Relation\_Item? Нет, я понятия не имею, что это. Я знаю только одно наверняка: это мне не помогает. Этот проект о фрилансерах и проектах. Этот класс делает что-то, связанное с поиском проектов (я предполагаю), но он не раскрывает это намерение. Ты когда-нибудь слышал, чтобы менеджер продукта говорил: «Вау, мы получили так много положительных отзывов о функции Search View Container Factory Project»?

Может быть, если я отступлю на шаг назад и посмотрю на структуру файлов, я что-то пойму лучше.

```php
    /**
     * @param array $models
     * @param int $type
     */
    private static function addItems(array $models, $type)
    {
        foreach ($models as $model) {
            $item = new Search_View_Container_Relation_Item(
                $model, 
                $type, 
                true
            );

            self::$_relationContainer->addItem($item, $type);
        }
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

6 / 327

---

И вот пример структуры файлов того старого проекта (именно та, что путает и не раскрывает сути):

```
classes git:(master) tree ./Search

./Search
├── Complex
│   └── Project.php
├── Factory
│   └── Project.php
├── Relation
│   └── Factory
│       └── Project.php
├── Simple
│   └── Project.php
└── View
    └── Container
        ├── Factory
        │   └── Project.php
        ├── Project.php
        └── Relation
            └── Project.php

9 directories, 7 files
```

Нет, всё равно понятия не имею. Вот моя мысль:

Технические термины и чрезмерно используемые шаблоны — отстой, когда речь идёт о высокоуровневых бизнес-приложениях.

Так что стратегическое проектирование — это всё о том, как **не** строить проекты вроде этого. А техническое проектирование даёт тебе некоторые полезные инструменты, чтобы этого добиться. На следующих страницах мы поговорим о следующих концепциях:

**Объекты-значения (Value Objects)**

Martin Joo — Предметно-ориентированное проектирование с Laravel

7 / 327

---

**Объекты передачи данных (Data Transfer Objects)**
**Репозитории (Repositories)**
**Пользовательские построители запросов (Custom Query Builders)**
**Сервисы (Services)**
**Действия (Actions)**
**View Models (View Models)**
**CQRS (CQRS)**
**Состояния и переходы (States and Transitions)**
**Домены и приложения (Domains and Applications)**

Martin Joo — Предметно-ориентированное проектирование с Laravel

8 / 327

---

**Работа с данными**

Работа с данными — один из самых критически важных аспектов любого бизнес-приложения.
К сожалению, PHP не слишком хорош в этом плане. На мой взгляд, одна из лучших и худших особенностей PHP — это массивы. Особенно ассоциативные массивы. Проблемы такие:

* Нет type-hints (подсказок типов)
* Не задокументированная структура
* Нет ограничений. Ты можешь положить модели продуктов, ID продуктов и массивы продуктов под один и тот же ключ.

Ассоциативные массивы — это большие неструктурированные куски данных. Не пойми меня неправильно: они могут быть полезны, но в то же время очень раздражают. Изначально PHP-массивы пытались решить все задачи: очереди, стеки, списки, хеш-таблицы и деревья. Всё. Но с его слабой типизацией поддерживать такие структуры данных крайне тяжело.

Если подумать, данные играют огромную роль в любом бизнес-приложении:

* Приходит запрос. Он содержит входящие данные.
* Бизнес-слой обрабатывает эти данные.
* Слой базы данных вставляет эти данные в БД.
* Возвращается ответ. Он содержит исходящие данные.

Так что тебе придётся работать с данными на каждом уровне приложения. К счастью, Laravel и DDD дают нам несколько очень умных концепций.

Martin Joo — Предметно-ориентированное проектирование с Laravel

9 / 327

---

**Объекты-значения (Value Objects)**

Объект-значение — это элементарный класс, который содержит в основном (но не только) скалярные данные. То есть это обёрточный класс, который связывает воедино связанную информацию. Давай посмотрим пример:

```php
class Percent
{
    public readonly ?float $value;
    public readonly string $formatted;

    public function __construct(float $value)
    {
        $this->value = $value;

        if ($value === null) {
            $this->formatted = '';
        } else {
            $this->formatted = number_format(
                $value * 100, 2
            ) . '%';
        }
    }

    public static function from(?float $value): self
    {
        return new self($value);
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

10 / 327

---

Этот класс представляет значение процента. Этот простой класс даёт тебе три преимущества:

* Он инкапсулирует логику, которая обрабатывает null-значения и представляет их в виде процентов.
* У тебя всегда есть два знака после запятой (по умолчанию) в процентах.
* Лучшие типы.

Важное замечание: бизнес-логика или вычисления **не** являются частью объекта-значения. Единственное исключение, которое я допускаю, — это базовое форматирование.

Под «лучшими типами» я имею в виду такие методы:
Ты берёшь float-значение и превращаешь его в «первоклассного гражданина» с помощью объекта Percent. Тебе больше не нужно беспокоиться о том, возвращает ли метод в твоём приложении отформатированную строку или число с плавающей точкой. Каждое процентное значение отныне может быть выражено как объект Percent. Так ты знаешь, что он содержит и число с плавающей точкой, и отформатированное строковое значение.

Оригинальное определение объекта-значения утверждает ещё две вещи:

* Он неизменяем. У тебя нет сеттеров, и есть только свойства только для чтения.
* Он не содержит ID или любого другого свойства, связанного с идентификацией. Два объекта-значения равны, только если их значения совпадают.

Что ещё можно выразить как объект-значение? Почти всё. Вот несколько примеров:

* **Адреса**. В e-commerce-приложении, где тебе нужно работать с доставкой, может быть очень полезно использовать объекты вместо строк. Ты можешь выразить каждую часть адреса как свойство:

```php
private function averageClickRate(int $total): Percent
{
    return Percent::from(
        SentMail::whereClicked()->count() / $total
    );
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

11 / 327

---

* Город (City)
* Почтовый индекс (ZIP code)
* Строка 1 (Line 1)
* Строка 2 (Line 2)

**Числа**. Любое финансовое приложение может выиграть от использования объектов-значений при вычислении метрик или сравнении чисел. Ты можешь выразить очень высокоуровневые концепции, например, маржу (Margin).

* Верхняя строка (Top Line, например, доход)
* Нижняя строка (Bottom Line, например, чистая прибыль)
* Маржа (Margin, конечно, в виде Percent)

**Адреса электронной почты (Email addresses)**

Или другие специфические для приложения концепции.

Давай рассмотрим пример с маржой подробнее:

Предположим, ты работал с финансовыми приложениями, которые имеют дело с публичными компаниями. Ты знаешь, что такие числа, как доход, даются в миллионах (или миллиардах в некоторых случаях, например, рыночная капитализация). Так что когда ты запрашиваешь доход Apple (который на момент написания составляет 378 миллиардов) из финансового API, ты получаешь не 378,323,000,000, а 378,323. И мы можем выразить это в коде так же:

```php
class Margin
{
    public function __construct(
        public readonly float $topLine,
        public readonly float $bottomLine,
        public readonly float $margin,
    ) {}
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

12 / 327

---

И мы можем использовать класс `Margin` вот так:

```php
class Margin
{
    public function __construct(
        public readonly Millions $topLine,
        public readonly Millions $bottomLine,
        public readonly Percent $margin,
    ) {}
}

class MetricsService
{
    public function profitMargin(IncomeStatement $incomeStatement): Margin
    {
        return new Margin(
            topLine: $incomeStatement->revenue,
            bottomLine: $incomeStatement->net_profit,
            margin: new Percent(
                $incomeStatement->net_profit->value / 
                $incomeStatement->revenue->value
            ),
        );
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

13 / 327

---

В этом примере я предполагаю, что `revenue` и `netProfit` — это экземпляры `Millions`.
Но разве `IncomeStatement` не является Eloquent-моделью?
Рад, что ты спросил. Да, является. И мы можем написать каст (преобразователь), который конвертирует `float` в `Millions`:

Он может использоваться в Eloquent-модели, и вот как это работает:

* Когда ты обращаешься к атрибуту модели, вызывается метод `get`. Так, `$incomeStatement->revenue` вернёт экземпляр `Millions`.
* Когда ты задаёшь атрибут модели, вызывается метод `set`. Так, `$incomeStatement->revenue = new Millions(1000)` вставит свойство `value` (1000) из экземпляра `Millions`.

```php
class MillionsCast implements CastsAttributes
{
    /**
     * @param float $value
     */
    public function get($model, $key, $value, $attributes)
    {
        return new Millions($value);
    }

    /**
     * @param Millions $millions
     */
    public function set($model, $key, $millions, $attributes)
    {
        return [
            $key => $millions->value,
        ];
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

14 / 327

---

Последняя часть — это использование каста в модели:

```php
protected $casts = [
    'revenue' => MillionsCast::class,
    'net_profit' => MillionsCast::class,
];
```

Итак, в двух словах, вот как использовать объект-значение. Подведём итог:

Используя объекты-значения, ты можешь создавать объекты из связанного скалярного набора данных.

Основные преимущества:

* Это делает твой код более высокоуровневым.
* Это проясняет вещи и помогает избежать путаницы. Например, теперь ты точно знаешь, что `Millions` содержит число, представленное в миллионах.
* Это помогает работать с nullable-значениями. Тебе больше не нужно писать `?float $revenue`. Ты можешь писать `Millions $revenue`.

В введении я писал, что данные — это ключевая часть любого приложения. Я дал тебе такой список:

* Приходит запрос. Он содержит входящие данные.
* Бизнес-слой обрабатывает эти данные.
* Слой базы данных вставляет эти данные в БД.
* Возвращается ответ. Он содержит исходящие данные.

Как ты можешь видеть на примерах с кастом и другими, объект-значение используется в основном **внутри** (но не исключительно!) нашего приложения. В следующей главе мы обсудим, что происходит на границах (запросы и ответы).

Martin Joo — Предметно-ориентированное проектирование с Laravel

15 / 327

---

**Объекты передачи данных (Data Transfer Objects)**

Следующая важная концепция — это объект передачи данных, или DTO. Это тоже простая концепция: это класс, который хранит данные. Эти данные затем передаются между компонентами. Что это за компоненты?

* Твоё приложение в целом
* Классы внутри твоего приложения

Давай посмотрим на прямолинейный пример:

Это, конечно, чрезмерно упрощённый пример. Я работаю над системой e-learning, и можешь мне поверить, запрос на создание нового курса просто перегружен.

```php
class CourseController extends Controller
{
    public function store(Request $request): Course
    {
        $course = Course::create($request->course);

        foreach ($request->lessons as $lesson) {
            // $lesson is an array
            $course->lessons()->create($lesson);
        }

        foreach ($request->student_ids as $studentId) {
            $course->students()->attach($studentId);
        }

        return $course;
    }
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

16 / 327

---

Со временем это действие станет более сложным, и ты захочешь его рефакторить. Давай вынесем это в сервис (позже мы подробнее поговорим о сервисах. Пока что: это класс, который реализует некоторую бизнес-логику):

```php
class CourseService
{
    public function create(array $data): Course
    {
        $course = Course::create($data);
        $this->createLessons($course, $data['lessons']);
        $this->addStudents($course, $data['student_ids']);

        return $course;
    }

    public function createLessons(
        Course $course, 
        array $lessons
    ): void {
        foreach ($lessons as $lesson) {
            // $lesson is an array
            $course->lessons()->create($lesson);
        }
    }

    public function addStudents(
        Course $course, 
        array $studentIds
    ): void {
        foreach ($studentIds as $studentId) {
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

17 / 327

---

Выглядит нормально, но видишь проблемы?

* Аргументы вроде этих: `array $data` или `array $lessons`
* Строки вроде этой: `$data['lessons']`

Моя самая большая проблема — я не хочу поддерживать и отлаживать огромные ассоциативные массивы через пять лет.

Приведённый выше пример очень базовый. А теперь, пожалуйста, представь свой любимый легаси-проект, где тебе приходится работать с методами вроде этого:

```php
public function createProduct(array $data)
{
    // Вставь здесь 673 строки кода

    /**
     * Тебе придётся провести реверс-инжиниринг всего этого бардака,
     * просто чтобы понять, какую форму имеет $data, верно?
     */
}
```

DTO могут решить эту проблему, структурируя твои неструктурированные данные. Тот же `CourseService` с DTO:

```php
$course->students()->attach($studentId);
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

18 / 327

---

```php
class CourseService
{
    public function create(CourseData $data): Course
    {
        $course = Course::create($data->all());
        $this->createLessons($course, $data->lessons);
        $this->addStudents($course, $data->student_ids);

        return $course;
    }

    /**
     * @param Collection<LessonData> $lessons
     */
    public function createLessons(
        Course $course, 
        Collection $lessons
    ): void {
        foreach ($lessons as $lesson) {
            // $lesson is an instance of LessonData
            $course->lessons()->create($lesson);
        }
    }

    public function addStudents(
        Course $course, 
        Collection $studentIds
    ): void {
        foreach ($studentIds as $studentId) {
            $course->students()->attach($studentId);
```

Martin Joo — Предметно-ориентированное проектирование с Laravel

19 / 327

---