Все DTO будут выглядеть примерно так:

```php
    public readonly ?int $id,
    public readonly string $email,
    public readonly string $first_name,
    public readonly ?string $last_name,

    /** @var DataCollection<TagData> */
    public readonly ?DataCollection $tags,
    public readonly ?FormData $form,
) {}
```

ID всегда является необязательным, потому что его нет при приходе запроса POST —
мы трансформируем входные данные в DTO.
Но когда приходит PUT-запрос — ID уже есть.
И помни: этот DTO также используется при запросе подписчиков и отправке ответа.

Свойства оформлены в `snake_case`. По умолчанию `laravel-data` сопоставляет
атрибуты модели и параметры запроса со свойствами DTO.
Используя `snake_case`, нам не нужно делать дополнительную работу.
Это также касается обычных DTO-классов (если ты не используешь `laravel-data`).
Если ты хочешь использовать `camelCase`, тебе придётся писать логику
по трансформации model\_attributes в dtoAttributes.
Раньше я так делал — но со временем это становится громоздко.
Поэтому теперь я везде использую `snake_case`:

* В моделях
* В DTO
* В параметрах запроса

`$form` — это вложенное свойство. Как ты видишь, есть класс `FormData`,
который является вложенным элементом в `SubscriberData`.
Так же, как модель `Subscriber` содержит атрибут `form`.
`laravel-data` делает такую вложенность очень простой. Мы поговорим об этом подробнее позже.

`$tags` — тоже вложенное свойство, но у подписчика может быть много тегов,
и как ты видишь, в DTO мы можем использовать `DataCollection` для маппинга.
Это из пакета `laravel-data`.

Martin Joo — Предметно-ориентированное проектирование с Laravel
Стр. 101 / 327

