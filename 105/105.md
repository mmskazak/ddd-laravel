Я расскажу об Action позже, а сейчас сосредоточимся на DTO.

Как ты можешь видеть, мы можем внедрить класс `SubscriberData` прямо в метод,
и пакет автоматически создаст новый экземпляр из запроса.
Но я также внедряю сам `Request`, чтобы получить текущего авторизованного пользователя.

Я мог бы добавить свойство `user` в `SubscriberData`,
но помни: мы также используем этот класс, чтобы возвращать данные в ответе.
А я **не хочу включать чувствительные данные пользователя в ответы**,
если в этом нет необходимости.
И в большинстве случаев пользователь **не нужен на фронтенде**.
Помни: когда пользователь залогинен в приложение, он видит **только свои** данные.
Нет смысла отображать, кто создал запись.
По этой причине я **не включаю пользователя в DTO**.

---

По умолчанию `laravel-data` делает **один-в-один маппинг** из запроса в DTO.
Для каждого свойства DTO будет искаться значение с таким же ключом в `Request`.

Это работает в большинстве случаев.
Но если ты посмотришь на DTO, то заметишь свойства вроде `tags` и `form`,
в то время как в запросе приходят ключи `tag_ids` и `form_id`.

**Как же переопределить поведение по умолчанию?**
Нужно определить метод `fromRequest` в DTO-классе:

```php
public static function fromRequest(Request $request): self
{
    return self::from([
        ...$request->all(),

        'tags' => TagData::collection(
            Tag::whereIn('id', $request->collect('tag_ids'))->get()
        ),

        'form' => FormData::from(
            Form::findOrNew($request->form_id)
        ),
    ]);
}
```

Martin Joo — Предметно-ориентированное проектирование с Laravel
Стр. 104 / 327