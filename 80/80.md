```sql
select count(*)
from sent_mails
where sent_at between "2022-01-01 00:00:00" and "2022-12-31 23:59:59";
```

Итак, ты создал индексы и написал хорошие запросы, но отчёты всё ещё медленные.
Что ещё можно сделать?

Ты всегда можешь проверить, нет ли проблемы N+1-запросов.
Это очень частая проблема при работе с ORM.

Можно оптимизировать `select *`-запросы.
Чаще всего нет необходимости выбирать все колонки.

Следующий шаг — **партиционирование базы данных**.
Я говорю о **горизонтальном партиционировании**.
Это способ сказать MySQL, как **физически хранить данные**.
Ты можешь разбить таблицу на несколько частей (партиций),
и движок будет сохранять эти части в разных файлах.
Например, можно задать правила такие как:

* `sent_mails` между 2022-01 и 2022-06 — это одна партиция.
* `sent_mails` между 2022-07 и 2022-12 — другая партиция.

Таким образом, ты пишешь запросы, которые касаются только части таблицы
(меньше строк нужно выбирать).

Если проблемы всё ещё есть — **можно использовать Redis**.
Эти исторические отчёты по своей природе **статичны**.
Если хочешь, можно полностью **реплицировать `sent_mails` в Redis**
и обслуживать запросы оттуда.
Существует десяток способов это сделать.

Martin Joo — Предметно-ориентированное проектирование с Laravel
Стр. 79 / 327